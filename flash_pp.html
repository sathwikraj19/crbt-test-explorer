<script>
  /* ========= EDITABLE DATA ========= */

  const phases = [
    {
      id: "kickoff",
      title: "Requirement & Kickoff",
      sub: "Scope freeze, timelines, use cases, dependencies",
      color: "var(--accent-1)",
    },
    {
      id: "config",
      title: "Flash Config & Routing",
      sub: "Environment readiness, service config, routing tables",
      color: "var(--accent-2)",
    },
    {
      id: "integration",
      title: "Integrations (SDP / IVR / Charging)",
      sub: "SDP, IVR, SMSC, charging & reporting integrations",
      color: "var(--accent-3)",
    },
    {
      id: "sit",
      title: "System Integration Testing (SIT)",
      sub: "Core flows, negative scenarios, capacity & failover",
      color: "var(--accent-1)",
    },
    {
      id: "uat",
      title: "User Acceptance Testing (UAT)",
      sub: "Client test cases execution, defect fixing & sign-off",
      color: "var(--accent-2)",
    },
    {
      id: "golive",
      title: "Go-Live & Hypercare",
      sub: "Cutover, production validation, monitoring & handover",
      color: "var(--accent-4)",
    },
  ];

  // status: "done" | "on-going" | "upcoming"
  let tasks = [
    {
      id: 1,
      phaseId: "kickoff",
      title: "Project Kick-off & Scope Freeze",
      owner: "SR",
      start: "2024-11-01",
      end:   "2024-11-03",
      status: "done",
      notes:
        "Kick-off meeting with client; agree on Flash scope, environments and high-level milestones.",
    },
    {
      id: 2,
      phaseId: "kickoff",
      title: "Requirement Walkthrough & KT",
      owner: "PM",
      start: "2024-11-02",
      end:   "2024-11-06",
      status: "on-going",
      notes:
        "Detailed walkthrough of flows (MO/MT), charging rules, reporting, alarms and dependencies.",
    },
    {
      id: 3,
      phaseId: "config",
      title: "Environment Readiness (UAT Flash)",
      owner: "RK",
      start: "2024-11-04",
      end:   "2024-11-08",
      status: "on-going",
      notes:
        "Validate UAT servers, connectivity, certificates, ports and base Flash installation.",
    },
    {
      id: 4,
      phaseId: "config",
      title: "Flash Service Config & Routing Tables",
      owner: "SR",
      start: "2024-11-07",
      end:   "2024-11-14",
      status: "upcoming",
      notes:
        "Configure Flash applications, IN parameters, routing logic and failover rules as per design.",
    },
    {
      id: 5,
      phaseId: "integration",
      title: "SDP / IVR Integration",
      owner: "AB",
      start: "2024-11-11",
      end:   "2024-11-18",
      status: "upcoming",
      notes:
        "End-to-end signalling integration with SDP / IVR, callback URLs and header validations.",
    },
    {
      id: 6,
      phaseId: "integration",
      title: "Charging & Billing Validation",
      owner: "RK",
      start: "2024-11-15",
      end:   "2024-11-20",
      status: "upcoming",
      notes:
        "Validate charging IDs, rate plans, free/chargeable calls and CDR generation for Flash.",
    },
    {
      id: 7,
      phaseId: "sit",
      title: "SIT – Core Call Flows",
      owner: "SR",
      start: "2024-11-19",
      end:   "2024-11-25",
      status: "upcoming",
      notes:
        "Run core inbound/outbound Flash scenarios, success & error flows, happy path coverage.",
    },
    {
      id: 8,
      phaseId: "sit",
      title: "SIT – Negative & Load Scenarios",
      owner: "AB",
      start: "2024-11-23",
      end:   "2024-11-28",
      status: "upcoming",
      notes:
        "Negative, timeout, retry and basic load tests; ensure stability with multiple concurrent calls.",
    },
    {
      id: 9,
      phaseId: "uat",
      title: "Client UAT Cycle",
      owner: "PM",
      start: "2024-11-26",
      end:   "2024-12-05",
      status: "upcoming",
      notes:
        "Client executes agreed UAT scenarios; track defects, re-deploy fixes and obtain UAT sign-off.",
    },
    {
      id: 10,
      phaseId: "golive",
      title: "Production Cutover & Sanity",
      owner: "RK",
      start: "2024-12-06",
      end:   "2024-12-08",
      status: "upcoming",
      notes:
        "Migrate configs to PROD, perform controlled cutover, run sanity calls and confirm KPIs.",
    },
    {
      id: 11,
      phaseId: "golive",
      title: "Hypercare Monitoring & Handover",
      owner: "SR",
      start: "2024-12-09",
      end:   "2024-12-18",
      status: "upcoming",
      notes:
        "Monitor Flash KPIs, alarms and CDRs; daily status with client and final handover to operations.",
    },
  ];

  // timeline range
  const timelineStart = new Date("2024-11-01");
  const timelineEnd   = new Date("2024-12-20");

  const MS_PER_DAY = 1000 * 60 * 60 * 24;
  const totalDays = Math.round((timelineEnd - timelineStart) / MS_PER_DAY) + 1;

  function dateToDayIndex(dateStr) {
    const d = new Date(dateStr);
    return Math.round((d - timelineStart) / MS_PER_DAY);
  }

  const phaseListEl = document.getElementById("phaseList");
  const headerRowEl = document.getElementById("timelineHeaderRow");
  const gridEl = document.getElementById("timelineGrid");
  const tooltipEl = document.getElementById("tooltip");
  const detailsEl = document.getElementById("taskDetails");
  const selectedStatusLabel = document.getElementById("selectedStatusLabel");

  /* ---------- render static structure ---------- */

  phases.forEach(phase => {
    const li = document.createElement("li");
    li.className = "phase-row";
    li.dataset.phaseId = phase.id;
    li.innerHTML = `
      <div class="phase-title" contenteditable="true">${phase.title}</div>
      <div class="phase-sub" contenteditable="true">${phase.sub}</div>
    `;
    phaseListEl.appendChild(li);
  });

  for (let i = 0; i < totalDays; i++) {
    const date = new Date(timelineStart.getTime() + i * MS_PER_DAY);
    const day = date.getDate();
    const short = date.toLocaleDateString("en-GB", { weekday: "short" });
    const cell = document.createElement("div");
    cell.className = "timeline-day";
    cell.innerHTML = `<div>${day}</div><div style="font-size:9px;">${short}</div>`;
    headerRowEl.appendChild(cell);
  }

  phases.forEach(phase => {
    const row = document.createElement("div");
    row.className = "timeline-grid-row";
    row.dataset.phaseId = phase.id;
    gridEl.appendChild(row);
  });

  /* ---------- custom status drag system (works mouse + touch) ---------- */

  let currentDragStatus = null;
  let dragBadgeEl = null;

  function startStatusDrag(status, x, y) {
    currentDragStatus = status;
    if (!dragBadgeEl) {
      dragBadgeEl = document.createElement("div");
      dragBadgeEl.textContent =
        status === "done" ? "Done" :
        status === "on-going" ? "On-Going" :
        "Upcoming";
      dragBadgeEl.style.position = "fixed";
      dragBadgeEl.style.zIndex = "9999";
      dragBadgeEl.style.pointerEvents = "none";
      dragBadgeEl.style.padding = "4px 10px";
      dragBadgeEl.style.borderRadius = "999px";
      dragBadgeEl.style.fontSize = "10px";
      dragBadgeEl.style.letterSpacing = "0.12em";
      dragBadgeEl.style.textTransform = "uppercase";
      dragBadgeEl.style.boxShadow = "0 10px 20px rgba(15,23,42,0.4)";
      dragBadgeEl.style.background =
        status === "done" ? "#bbf7d0" :
        status === "on-going" ? "#bae6fd" :
        "#fef9c3";
      dragBadgeEl.style.color = "#0f172a";
      document.body.appendChild(dragBadgeEl);
    }
    updateDragBadge(x, y);
  }

  function updateDragBadge(x, y) {
    if (!dragBadgeEl) return;
    dragBadgeEl.style.left = x + 12 + "px";
    dragBadgeEl.style.top  = y + 12 + "px";
  }

  function stopStatusDrag() {
    currentDragStatus = null;
    if (dragBadgeEl) {
      dragBadgeEl.remove();
      dragBadgeEl = null;
    }
    document.querySelectorAll(".task-bar.drag-over").forEach(b => b.classList.remove("drag-over"));
  }

  function makeStatusDragSource(element, getStatusFn) {
    if (!element) return;

    element.addEventListener("pointerdown", e => {
      e.preventDefault();
      const status = getStatusFn();
      if (!status) return;
      startStatusDrag(status, e.clientX, e.clientY);

      const moveHandler = ev => {
        updateDragBadge(ev.clientX, ev.clientY);
        // highlight bar under cursor
        const bar = ev.target.closest(".task-bar");
        document.querySelectorAll(".task-bar.drag-over").forEach(b => b.classList.remove("drag-over"));
        if (bar) bar.classList.add("drag-over");
      };

      const upHandler = ev => {
        const bar = ev.target.closest(".task-bar");
        if (bar && currentDragStatus) {
          const id = Number(bar.dataset.taskId);
          const task = tasks.find(t => t.id === id);
          if (task) {
            task.status = currentDragStatus;
            populateTaskSelect();
            renderTasks(document.querySelector(".chip--active").dataset.filter);
            fillEditorWithTask(id);
            showTaskDetails(id);
          }
        }
        stopStatusDrag();
        window.removeEventListener("pointermove", moveHandler);
        window.removeEventListener("pointerup", upHandler);
      };

      window.addEventListener("pointermove", moveHandler);
      window.addEventListener("pointerup", upHandler);
    });
  }

  /* ---------- gantt render ---------- */

  function clearTaskBars() {
    document.querySelectorAll(".task-bar").forEach(el => el.remove());
  }

  function renderTasks(filterStatus = "all") {
    clearTaskBars();

    tasks.forEach(task => {
      if (filterStatus !== "all" && task.status !== filterStatus) return;

      const row = document.querySelector(`.timeline-grid-row[data-phase-id="${task.phaseId}"]`);
      if (!row) return;

      const startIndex = dateToDayIndex(task.start);
      const endIndex   = dateToDayIndex(task.end);
      const durationDays = endIndex - startIndex + 1;

      const leftPercent  = (startIndex / totalDays) * 100;
      const widthPercent = (durationDays / totalDays) * 100;

      const bar = document.createElement("div");
      bar.className = "task-bar";
      bar.dataset.taskId = task.id;
      bar.dataset.status = task.status;

      const phase = phases.find(p => p.id === task.phaseId);
      const bgColor = phase ? phase.color : "var(--accent-1)";
      bar.style.background = bgColor;
      bar.style.left  = leftPercent + "%";
      bar.style.width = widthPercent + "%";

      const statusLabel =
        task.status === "done" ? "Done" :
        task.status === "on-going" ? "On-Going" : "Upcoming";

      bar.innerHTML = `
        <span class="task-pill">${statusLabel}</span>
        <span class="task-title">${task.title}</span>
        <span class="task-avatar">${task.owner}</span>
      `;

      row.appendChild(bar);
    });

    attachTaskEvents();
  }

  function renderTodayLine() {
    const today = new Date();
    if (today < timelineStart || today > timelineEnd) return;

    const index = Math.round((today - timelineStart) / MS_PER_DAY);
    const leftPercent = (index / totalDays) * 100;

    const todayLine = document.getElementById("todayLine");
    todayLine.style.display = "block";
    todayLine.style.left = leftPercent + "%";

    const label = todayLine.querySelector(".today-label");
    label.style.left = "0";
    label.style.transform = "translate(-50%, -70%)";
  }

  function moveTooltip(e) {
    const padding = 12;
    tooltipEl.style.left = e.clientX + padding + "px";
    tooltipEl.style.top  = e.clientY + padding + "px";
  }

  function showTaskDetails(taskId) {
    const task  = tasks.find(t => t.id === taskId);
    if (!task) return;
    const phase = phases.find(p => p.id === task.phaseId);
    const phaseTitle = phase ? phase.title : "";
    const statusText =
      task.status === "done" ? "Done" :
      task.status === "on-going" ? "On-Going" : "Upcoming";

    selectedStatusLabel.textContent = statusText;
    detailsEl.innerHTML = `
      <p><strong>${task.title}</strong></p>
      <p style="margin-top:4px;">${task.notes || ""}</p>
      <div class="pill-row">
        <span class="info-pill">Phase: ${phaseTitle}</span>
        <span class="info-pill">Owner: ${task.owner}</span>
        <span class="info-pill">Start: ${task.start}</span>
        <span class="info-pill">End: ${task.end}</span>
        <span class="info-pill">Status: ${statusText}</span>
      </div>
    `;
  }

  function attachTaskEvents() {
    document.querySelectorAll(".task-bar").forEach(bar => {
      const taskId = Number(bar.dataset.taskId);
      const task = tasks.find(t => t.id === taskId);
      if (!task) return;
      const phase = phases.find(p => p.id === task.phaseId);
      const phaseTitle = phase ? phase.title : "";
      const statusText =
        task.status === "done" ? "Done" :
        task.status === "on-going" ? "On-Going" : "Upcoming";

      // tooltip
      bar.addEventListener("mouseenter", e => {
        tooltipEl.innerHTML = `
          <div class="tooltip-title">${task.title}</div>
          <div class="tooltip-line">
            <span><strong>Phase:</strong> ${phaseTitle}</span>
            <span><strong>Owner:</strong> ${task.owner}</span>
          </div>
          <div class="tooltip-line" style="margin-top:4px;">
            <span><strong>Start:</strong> ${task.start}</span>
            <span><strong>End:</strong> ${task.end}</span>
          </div>
          <div style="margin-top:4px;"><strong>Status:</strong> ${statusText}</div>
        `;
        tooltipEl.classList.add("visible");
        moveTooltip(e);
      });

      bar.addEventListener("mousemove", moveTooltip);
      bar.addEventListener("mouseleave", () => tooltipEl.classList.remove("visible"));

      bar.addEventListener("click", () => {
        document.querySelectorAll(".task-bar").forEach(b => (b.style.outline = "none"));
        bar.style.outline = "2px solid rgba(56, 189, 248, 0.85)";
        fillEditorWithTask(taskId);
        showTaskDetails(taskId);
      });

      // while dragging a status, highlight bar under cursor
      bar.addEventListener("pointerenter", () => {
        if (currentDragStatus) bar.classList.add("drag-over");
      });
      bar.addEventListener("pointerleave", () => {
        bar.classList.remove("drag-over");
      });

      // make the pill itself a drag source for its status
      const pill = bar.querySelector(".task-pill");
      makeStatusDragSource(pill, () => task.status);
    });
  }

  /* ---------- filters ---------- */

  document.querySelectorAll(".chip").forEach(chip => {
    chip.addEventListener("click", () => {
      const filter = chip.dataset.filter;
      document.querySelectorAll(".chip").forEach(c => c.classList.remove("chip--active"));
      chip.classList.add("chip--active");
      renderTasks(filter);
    });
  });

  /* ---------- make right-side stickers drag sources ---------- */

  document.querySelectorAll(".status-sticker").forEach(sticker => {
    makeStatusDragSource(sticker, () => sticker.dataset.status);
  });

  /* ---------- task editor wiring ---------- */

  const taskSelect = document.getElementById("taskSelect");
  const phaseSelect = document.getElementById("taskPhase");
  const titleInput = document.getElementById("taskTitle");
  const ownerInput = document.getElementById("taskOwner");
  const statusSelect = document.getElementById("taskStatus");
  const startInput = document.getElementById("taskStart");
  const endInput   = document.getElementById("taskEnd");
  const notesInput = document.getElementById("taskNotes");

  function populatePhaseSelect() {
    phaseSelect.innerHTML = "";
    phases.forEach(p => {
      const opt = document.createElement("option");
      opt.value = p.id;
      opt.textContent = p.title;
      phaseSelect.appendChild(opt);
    });
  }

  function populateTaskSelect() {
    taskSelect.innerHTML = "";
    tasks.forEach(t => {
      const opt = document.createElement("option");
      opt.value = t.id;
      opt.textContent = `${t.id}. ${t.title}`;
      taskSelect.appendChild(opt);
    });
  }

  function fillEditorWithTask(taskId) {
    const task = tasks.find(t => t.id === Number(taskId));
    if (!task) return;
    taskSelect.value = task.id;
    titleInput.value  = task.title;
    ownerInput.value  = task.owner;
    phaseSelect.value = task.phaseId;
    statusSelect.value = task.status;
    startInput.value  = task.start;
    endInput.value    = task.end;
    notesInput.value  = task.notes || "";
  }

  taskSelect.addEventListener("change", () => {
    fillEditorWithTask(taskSelect.value);
    showTaskDetails(Number(taskSelect.value));
  });

  document.getElementById("saveTaskBtn").addEventListener("click", () => {
    const id = Number(taskSelect.value);
    const task = tasks.find(t => t.id === id);
    if (!task) return;

    task.title   = titleInput.value.trim() || "Untitled Task";
    task.owner   = ownerInput.value.trim() || "--";
    task.phaseId = phaseSelect.value;
    task.status  = statusSelect.value;
    if (startInput.value) task.start = startInput.value;
    if (endInput.value)   task.end   = endInput.value;
    task.notes   = notesInput.value.trim();

    populateTaskSelect();
    renderTasks(document.querySelector(".chip--active").dataset.filter);
    fillEditorWithTask(id);
    showTaskDetails(id);
  });

  document.getElementById("addTaskBtn").addEventListener("click", () => {
    const newId = tasks.length ? Math.max(...tasks.map(t => t.id)) + 1 : 1;
    const newTask = {
      id: newId,
      title: titleInput.value.trim() || "New Task",
      owner: ownerInput.value.trim() || "--",
      phaseId: phaseSelect.value,
      status: statusSelect.value,
      start: startInput.value || new Date().toISOString().slice(0,10),
      end:   endInput.value   || new Date().toISOString().slice(0,10),
      notes: notesInput.value.trim(),
    };
    tasks.push(newTask);
    populateTaskSelect();
    renderTasks(document.querySelector(".chip--active").dataset.filter);
    fillEditorWithTask(newId);
    showTaskDetails(newId);
  });

  /* ---------- init ---------- */

  populatePhaseSelect();
  populateTaskSelect();
  fillEditorWithTask(tasks[0].id);
  showTaskDetails(tasks[0].id);
  renderTasks("all");
  renderTodayLine();
</script>
